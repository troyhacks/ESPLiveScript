src/NodeToken.h:3871:17: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
            c = __num & 0xff;
                ^
src/NodeToken.h:3865:46: note: Address of variable taken here.
            __num = (uint32_t)(*((uint32_t *)&__f));
                                             ^
src/NodeToken.h:3863:19: note: Variable created here.
            float __f = 0;
                  ^
src/NodeToken.h:3871:17: note: Using object that points to local variable '__f' that is out of scope.
            c = __num & 0xff;
                ^
src/NodeToken.h:3874:21: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
            __num = __num / 256;
                    ^
src/NodeToken.h:3865:46: note: Address of variable taken here.
            __num = (uint32_t)(*((uint32_t *)&__f));
                                             ^
src/NodeToken.h:3863:19: note: Variable created here.
            float __f = 0;
                  ^
src/NodeToken.h:3874:21: note: Using object that points to local variable '__f' that is out of scope.
            __num = __num / 256;
                    ^
src/string_function.h:42:15: information: --check-library: There is no matching configuration for function std::string() [checkLibraryFunction]
  return std::string(buf.get(),
              ^
src/asm_struct_enum.h:165:27: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
      _it = _texts.insert(next(_it), m);
                          ^
src/asm_struct_enum.h:171:14: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      return string(_texts.back());
             ^
src/asm_struct_enum.h:175:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
  string current() { return string(*_it); }
                            ^
src/asm_struct_enum.h:177:15: information: --check-library: There is no matching configuration for function findText() [checkLibraryFunction]
    int pos = findText(" ");
              ^
src/asm_struct_enum.h:190:14: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      return string(_texts.front());
             ^
src/asm_struct_enum.h:196:14: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      return string(_texts[pos]);
             ^
src/asm_struct_enum.h:220:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      if (s.compare(string(*_it)) == 0) {
                    ^
src/tokenizer.h:683:11: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
      if (next(it) == script.end()) {
          ^
src/tokenizer.h:688:14: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
        it = next(it);
             ^
src/NodeToken.h:25:3: information: --check-library: There is no matching configuration for function ESP_LOGD() [checkLibraryFunction]
  ESP_LOGD("ESPLiveScript", "%s\r\n", str.c_str());
  ^
src/NodeToken.h:108:36: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
  UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                   ^
src/NodeToken.h:126:22: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
void displayStat() { displayStat(""); }
                     ^
src/NodeToken.h:138:36: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
  UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                   ^
src/NodeToken.h:662:13: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        if (string(getTargetText()).compare(0, 1, "@") == 0) {
            ^
src/NodeToken.h:665:17: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
        int i = findMember(_vartype, string(getTargetText()));
                ^
src/NodeToken.h:665:38: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        int i = findMember(_vartype, string(getTargetText()));
                                     ^
src/NodeToken.h:694:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        int cmp = getChildAtPos(2)->getChildAtPos(i)->findMaxArgumentSize();
                                    ^
src/NodeToken.h:1369:11: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    res = string(p->getTargetText());
          ^
src/NodeToken.h:1513:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    } else if (string(nd->getTokenText()).find("x") != string::npos) {
               ^
src/NodeToken.h:1990:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string sd = string(nd->getTargetText());
                ^
src/NodeToken.h:2379:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          nd->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size);
                                ^
src/NodeToken.h:2556:24: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      content.addAfter(string(_div[i]));
                       ^
src/NodeToken.h:2803:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
  nd->setTargetText(string(nd->parent->getTargetText()));
                    ^
src/NodeToken.h:3049:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (nd->getChildAtPos(0)->getChildAtPos(j)->findMaxArgumentSize() - 1 >=
                                ^
src/NodeToken.h:3070:30: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    if (t->getChildAtPos(0)->getChildAtPos(i)->isPointer) {
                             ^
src/NodeToken.h:3072:29: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                            ^
src/NodeToken.h:3085:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        if (func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType ==
                                    ^
src/NodeToken.h:3091:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                    ^
src/NodeToken.h:3092:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3097:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3100:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL and
                                ^
src/NodeToken.h:3104:35: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType,
                                  ^
src/NodeToken.h:3111:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType;
                                    ^
src/NodeToken.h:3114:36: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
              t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                   ^
src/NodeToken.h:3127:34: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                 ^
src/NodeToken.h:3147:19: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                ->getChildAtPos(i)
                  ^
src/NodeToken.h:3175:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                  ->getChildAtPos(i)
                                    ^
src/NodeToken.h:3186:21: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                  ->getChildAtPos(i)
                    ^
src/NodeToken.h:3200:21: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                  ->getChildAtPos(i)
                    ^
src/NodeToken.h:3213:28: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                         ->getChildAtPos(i)
                           ^
src/NodeToken.h:3220:56: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                                     ->getChildAtPos(i)
                                                       ^
src/NodeToken.h:3229:56: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                                     ->getChildAtPos(i)
                                                       ^
src/NodeToken.h:3234:28: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                         ->getChildAtPos(i)
                           ^
src/NodeToken.h:3278:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          v = func->getChildAtPos(1)->getChildAtPos(i)->getVarType();
                                      ^
src/NodeToken.h:3280:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          v = nd->getChildAtPos(0)->getChildAtPos(i)->getVarType();
                                    ^
src/NodeToken.h:3333:35: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (func->getChildAtPos(1)->getChildAtPos(i)->isPointer) {
                                  ^
src/NodeToken.h:3337:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3340:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE;
                                    ^
src/NodeToken.h:3364:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                    ^
src/NodeToken.h:3367:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3371:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE +
                                    ^
src/NodeToken.h:3372:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size;
                                    ^
src/NodeToken.h:3374:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1;
                                    ^
src/NodeToken.h:3376:42: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
             j < func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size;
                                         ^
src/NodeToken.h:3379:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL) {
                                    ^
src/NodeToken.h:3382:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType,
                                      ^
src/NodeToken.h:3393:26: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                       ->getChildAtPos(i)
                         ^
src/NodeToken.h:3397:43: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                        ->getChildAtPos(i)
                                          ^
src/NodeToken.h:3416:41: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size -
                                        ^
src/NodeToken.h:3435:41: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size -
                                        ^
src/NodeToken.h:3581:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:3849:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string str = string(nd->getChildAtPos(0)->getTokenText());
                   ^
src/NodeToken.h:4041:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string sd = string(nd->getTargetText());
                ^
src/NodeToken.h:4221:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string sd = string(nd->getTargetText());
                ^
src/NodeToken.h:4464:19: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
  string target = string(nd->getTokenText());
                  ^
src/NodeToken.h:4518:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string tmp = string((*text->getChildAtPos(i)));
                   ^
src/NodeToken.h:4580:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string tmp = string((*text->getChildAtPos(i)));
                 ^
src/NodeToken.h:4619:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string tmp = string((*text->getChildAtPos(i)));
                   ^
src/NodeToken.h:4664:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string tmp = string((*text->getChildAtPos(i)));
                   ^
src/asm_parser.h:436:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      if (trim(string((*it)->getText())).compare(trim(s)) == 0) {
               ^
src/asm_parser.h:472:19: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    if (findLabel(string(res.getText()), asm_parsed) != -1) {
                  ^
src/asm_parser.h:903:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:928:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:1169:3: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
  displayStat("before mem");
  ^
src/asm_parser.h:1173:3: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
  displayStat("after mem");
  ^
src/asm_parser.h:1372:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string(parse_line->getText()), asm_parsed);
                            ^
src/asm_parser.h:1524:40: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      vector<string> args = split(trim(string((*it2)->getText())), " ");
                                       ^
src/asm_parser.h:1529:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string((*it)->getText()), asm_parsed);
                            ^
src/asm_parser.h:1534:30: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string stackstring = string((*it)->getText()).insert(2, "stack_");
                             ^
src/asm_parser.h:1560:3: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
  displayStat("before call parsem");
  ^
src/asm_parser.h:1598:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name, FILE_WRITE);
                 ^
src/asm_parser.h:1599:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)"ESPLiveScript1.0.1", 19);
       ^
src/asm_parser.h:1600:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/asm_parser.h:1603:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->instruction_size, 2);
       ^
src/asm_parser.h:1606:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->data_size, 2);
       ^
src/asm_parser.h:1609:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->function_size, 2);
       ^
src/asm_parser.h:1612:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->binary_data, bin->tmp_instruction_size);
       ^
src/asm_parser.h:1613:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->function_data, bin->function_size);
       ^
src/execute_asm.h:7:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(bin->binary_data);
    ^
src/execute_asm.h:9:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(bin->function_data);
    ^
src/execute_asm.h:60:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLink(string(textptr).substr(6, 100), externalType::value);
                           ^
src/execute_asm.h:88:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          findLink(string(textptr).substr(2, 100), externalType::function);
                   ^
src/execute_asm.h:127:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.name = string(textptr);
                ^
src/execute_asm.h:132:22: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.variables = string(textptr);
                     ^
src/execute_asm.h:163:19: information: --check-library: There is no matching configuration for function heap_caps_malloc() [checkLibraryFunction]
      (uint32_t *)heap_caps_malloc(bin->instruction_size, MALLOC_CAP_EXEC);
                  ^
src/execute_asm.h:257:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name);
                 ^
src/execute_asm.h:260:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)ver, 19);
       ^
src/execute_asm.h:268:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/execute_asm.h:271:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->instruction_size, 2);
       ^
src/execute_asm.h:274:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->data_size, 2);
       ^
src/execute_asm.h:277:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->function_size, 2);
       ^
src/execute_asm.h:282:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp, bin->tmp_instruction_size);
       ^
src/execute_asm.h:285:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp2, bin->function_size);
       ^
src/execute_asm.h:389:5: information: --check-library: There is no matching configuration for function heap_caps_aligned_free() [checkLibraryFunction]
    heap_caps_aligned_free(ex->start_program);
    ^
src/execute_asm.h:396:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(ex->data);
    ^
src/execute.h:64:3: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
  vTaskDelay(1);
  ^
src/execute.h:106:9: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
        vTaskSuspend(__run_handles[i]);
        ^
src/execute.h:115:9: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
        vTaskResume(__run_handles[i]);
        ^
src/execute.h:126:5: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    xEventGroupSync(xCreatedEventGroup, MASK, MASK, portMAX_DELAY);
    ^
src/execute.h:127:5: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
    vTaskDelay(10);
    ^
src/execute.h:128:5: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    xEventGroupSync(xCreatedEventGroup2, MASK, MASK, portMAX_DELAY);
    ^
src/execute.h:191:14: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
  uxReturn = xEventGroupSync(xCreatedEventGroup, 1 << h, MASK, portMAX_DELAY);
             ^
src/execute.h:197:7: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
      xEventGroupClearBits(xCreatedEventGroup, MASK);
      ^
src/execute.h:207:7: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
      xEventGroupSync(xCreatedEventGroup2, 1 << h, MASK, portMAX_DELAY);
      ^
src/execute.h:213:7: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
      xEventGroupClearBits(xCreatedEventGroup2, MASK);
      ^
src/execute.h:216:5: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    xEventGroupSync(xCreatedEventGroup2, 1 << h, MASK, portMAX_DELAY);
    ^
src/execute.h:311:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:313:9: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
        vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
        ^
src/execute.h:318:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:334:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:335:7: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
      vTaskResume(*runningPrograms.getHandleByIndex(__run_handle_index));
      ^
src/execute.h:350:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:356:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(30);
      ^
src/execute.h:359:9: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
        vTaskDelete(*runningPrograms.getHandleByIndex(__run_handle_index));
        ^
src/execute.h:363:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(30);
      ^
src/execute.h:369:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:407:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(20);
      ^
src/execute.h:425:7: information: --check-library: There is no matching configuration for function xTaskCreateUniversal() [checkLibraryFunction]
      xTaskCreateUniversal(
      ^
src/execute.h:572:3: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
  vTaskDelete(NULL);
  ^
src/ESPLiveScript.h:202:5: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
    displayStat("afterclen");
    ^
src/ESPLiveScript.h:442:23: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          string sd = string(current_node->getTargetText());
                      ^
src/ESPLiveScript.h:486:13: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
        i = findMember(current_node->getVarType(),
            ^
src/ESPLiveScript.h:487:24: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                       string(current()->getText()));
                       ^
src/ESPLiveScript.h:498:48: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        i = findMember(current_node->_vartype, string(current()->getText()));
                                               ^
src/ESPLiveScript.h:542:18: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
      current()->addText(
                 ^
src/ESPLiveScript.h:584:13: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          ->getChildAtPos(0)
            ^
src/ESPLiveScript.h:610:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node = current_node->addChild(NodeToken(inputArgumentsNode));
                                 ^
src/ESPLiveScript.h:790:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                         string(sav_t.back().getText())) == 0) {
                         ^
src/ESPLiveScript.h:909:44: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (search_result->getChildAtPos(1)->getChildAtPos(i)->_vartype ==
                                           ^
src/ESPLiveScript.h:948:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node = current_node->addChild(NodeToken(current(), comparatorNode));
                                 ^
src/ESPLiveScript.h:971:19: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node->addChild(NodeToken(statementNode));
                  ^
src/ESPLiveScript.h:974:21: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node->addChild(NodeToken(current(), stringNode));
                    ^
src/ESPLiveScript.h:987:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(c, breakNode));
                      ^
src/ESPLiveScript.h:1006:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(c, continueNode));
                      ^
src/ESPLiveScript.h:1018:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(returnNode));
                      ^
src/ESPLiveScript.h:1022:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(returnNode));
                                     ^
src/ESPLiveScript.h:1097:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(assignementNode));
                                   ^
src/ESPLiveScript.h:1103:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                   ^
src/ESPLiveScript.h:1133:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(assignementNode));
                                   ^
src/ESPLiveScript.h:1208:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(binOpNode));
                                     ^
src/ESPLiveScript.h:1291:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(
                                   ^
src/ESPLiveScript.h:1339:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(
                                     ^
src/ESPLiveScript.h:1407:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(
                                     ^
src/ESPLiveScript.h:1474:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(
                                     ^
src/ESPLiveScript.h:1477:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(statementNode));
                                     ^
src/ESPLiveScript.h:1504:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(statementNode));
                                     ^
src/ESPLiveScript.h:1600:22: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
          current()->addText(string_format(
                     ^
src/ESPLiveScript.h:1638:25: information: --check-library: There is no matching configuration for function Context::findVariable() [checkLibraryFunction]
          current_cntx->findVariable(nodeTokenList.get().getTokenText(), false);
                        ^
src/ESPLiveScript.h:1650:22: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
          current()->addText(string_format(
                     ^
src/ESPLiveScript.h:1692:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(assignementNode));
                                     ^
src/ESPLiveScript.h:1793:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(current(), blockStatementNode));
                      ^
src/ESPLiveScript.h:1828:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node = current_node->addChild(NodeToken(defInputArgumentsNode));
                                 ^
src/ESPLiveScript.h:2114:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(ternaryIfNode));
                                   ^
src/ESPLiveScript.h:2148:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(binOpNode));
                                   ^
src/ESPLiveScript.h:2191:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(binOpNode));
                                   ^
src/ESPLiveScript.h:2242:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(testNode));
                                   ^
src/ESPLiveScript.h:2302:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(binOpNode));
                                   ^
src/ESPLiveScript.h:2350:21: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node->addChild(NodeToken(current(), numberNode));
                    ^
src/ESPLiveScript.h:2377:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                   ^
src/ESPLiveScript.h:2403:25: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
          current_node->addChild(NodeToken(current(), changeTypeNode));
                        ^
src/ESPLiveScript.h:2530:18: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
      current()->addText(
                 ^
src/ESPLiveScript.h:2537:13: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          ->getChildAtPos(2)
            ^
src/ESPLiveScript.h:2563:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(current(), numberNode));
                                   ^
src/ESPLiveScript.h:2626:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      program.addChildFront(nd)->addChild(NodeToken(current(), stringNode));
                                 ^
src/ESPLiveScript.h:2724:37: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          sizestr = sizestr + " " + string(current()->getText());
                                    ^
src/ESPLiveScript.h:2739:39: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            sizestr = sizestr + " " + string(current()->getText());
                                      ^
src/ESPLiveScript.h:2844:26: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
              current()->addText(string_format("%s._@%s", usded.varName.c_str(),
                         ^
src/ESPLiveScript.h:2862:26: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
              current()->addText(string_format("%s.%s", usded.varName.c_str(),
                         ^
src/ESPLiveScript.h:3038:28: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                current()->addText(string_format(
                           ^
src/ESPLiveScript.h:3056:29: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
              current_node->addChild(NodeToken(current(), stringNode));
                            ^
src/ESPLiveScript.h:3117:26: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
              current()->addText(string_format(
                         ^
src/ESPLiveScript.h:3157:44: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
              current_node = current_node->addChild(NodeToken(assignementNode));
                                           ^
src/asm_struct_enum.h:58:5: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
    push(sav + 1);
    ^
src/asm_struct_enum.h:66:5: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
    push(sav - 1);
    ^
src/asm_struct_enum.h:466:3: warning: Member variable 'result_parse_line::bincode' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:466:3: warning: Member variable 'result_parse_line::size' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:466:3: warning: Member variable 'result_parse_line::op' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:466:3: warning: Member variable 'result_parse_line::address' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:466:3: warning: Member variable 'result_parse_line::align' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:466:3: warning: Member variable 'result_parse_line::line' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:675:3: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
  _arguments() { vartype = __unknown__; }
  ^
src/asm_struct_enum.h:675:3: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
  _arguments() { vartype = __unknown__; }
  ^
src/asm_struct_enum.h:676:3: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
  _arguments(int val) {
  ^
src/asm_struct_enum.h:680:3: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
  _arguments(float val) {
  ^
src/tokenizer.h:770:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token() {
  ^
src/tokenizer.h:778:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token(tokenType h) {
  ^
src/tokenizer.h:785:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token(tokenType _type, int __vartype, int _line) {
  ^
src/tokenizer.h:792:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token(tokenType _type, int __vartype) {
  ^
src/tokenizer.h:841:3: warning: Member variable 'Tokens::_script' is not initialized in the constructor. [uninitMemberVar]
  Tokens() {
  ^
src/execute.h:71:3: warning: Member variable '_executablesClass::nb_concurrent_programs_current' is not initialized in the constructor. [uninitMemberVar]
  _executablesClass() {
  ^
src/execute.h:235:3: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
  Executable() {
  ^
src/execute.h:235:3: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
  Executable() {
  ^
src/execute.h:243:3: warning: Member variable 'Executable::__run_handle_index' is not initialized in the constructor. [uninitMemberVar]
  Executable(executable _executable) {
  ^
src/execute.h:243:3: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
  Executable(executable _executable) {
  ^
src/execute.h:243:3: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
  Executable(executable _executable) {
  ^
src/asm_struct_enum.h:17:3: warning:inconclusive: Member variable 'Stack < int >::_default' is not initialized in the constructor. [uninitMemberVar]
  Stack() {}
  ^
src/asm_struct_enum.h:17:3: warning:inconclusive: Member variable 'Stack < varTypeEnum >::_default' is not initialized in the constructor. [uninitMemberVar]
  Stack() {}
  ^
src/asm_struct_enum.h:18:18: performance: Variable '_default' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  Stack(T def) { _default = def; }
                 ^
src/asm_struct_enum.h:175:10: style:inconclusive: Technically the member function 'Text::current' can be const. [functionConst]
  string current() { return string(*_it); }
         ^
src/asm_struct_enum.h:194:10: style:inconclusive: Technically the member function 'Text::textAt' can be const. [functionConst]
  string textAt(int pos) {
         ^
src/asm_struct_enum.h:309:7: style:inconclusive: Technically the member function 'Text::size' can be const. [functionConst]
  int size() { return _texts.size(); }
      ^
src/asm_struct_enum.h:344:7: style:inconclusive: Technically the member function 'Text::get' can be const. [functionConst]
  int get() { return position - 1; }
      ^
src/asm_struct_enum.h:700:7: style:inconclusive: Technically the member function 'Arguments::size' can be const. [functionConst]
  int size() { return _args.size(); }
      ^
src/tokenizer.h:695:8: style:inconclusive: Technically the member function 'Script::currentChar' can be const. [functionConst]
  char currentChar() {
       ^
src/tokenizer.h:800:13: style:inconclusive: Technically the member function 'Token::getType' can be const. [functionConst]
  tokenType getType() { return (tokenType)type; }
            ^
src/tokenizer.h:856:7: style:inconclusive: Technically the member function 'Tokens::size' can be const. [functionConst]
  int size() { return _tokens.size(); }
      ^
src/NodeToken.h:682:12: style:inconclusive: Technically the member function 'NodeToken::getNodeTokenType' can be const. [functionConst]
  nodeType getNodeTokenType() { return (nodeType)_nodetype; }
           ^
src/NodeToken.h:683:7: style:inconclusive: Technically the member function 'NodeToken::children_size' can be const. [functionConst]
  int children_size() {
      ^
src/NodeToken.h:965:8: performance:inconclusive: Technically the member function 'Context::addFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  void addFunction(NodeToken *nd) {
       ^
src/NodeToken.h:1003:8: performance:inconclusive: Technically the member function 'Context::findCandidate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  bool findCandidate(char *str) {
       ^
src/NodeToken.h:1028:8: performance:inconclusive: Technically the member function 'Context::findFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  void findFunction(Token *t) {
       ^
src/execute.h:147:7: performance:inconclusive: Technically the member function '_executablesClass::getFirstHandle' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  int getFirstHandle() {
      ^
src/execute.h:455:8: style:inconclusive: Technically the member function 'Executable::isExeExists' can be const. [functionConst]
  bool isExeExists() { return exeExist; }
       ^
src/execute.h:531:8: style:inconclusive: Technically the member function 'Executable::isRunning' can be const. [functionConst]
  bool isRunning() { return _isRunning; }
       ^
src/ESPLiveScript.h:94:7: performance:inconclusive: Technically the member function 'Parser::size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  int size() { return _tks->size(); }
      ^
src/ESPLiveScript.h:100:8: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  bool Match(tokenType tt) { return _tks->Match(tt); }
       ^
src/ESPLiveScript.h:101:8: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  bool Match(tokenType tt, int index) { return _tks->Match(tt, index); }
       ^
src/asm_struct_enum.h:676:3: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  _arguments(int val) {
  ^
src/asm_struct_enum.h:680:3: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  _arguments(float val) {
  ^
src/tokenizer.h:778:3: style: Class 'Token' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Token(tokenType h) {
  ^
src/NodeToken.h:418:3: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NodeToken(nodeType tt) {
  ^
src/NodeToken.h:429:3: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NodeToken(Token *t) {
  ^
src/NodeToken.h:505:3: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NodeToken(NodeToken *nd) {
  ^
src/execute.h:243:3: style: Class 'Executable' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Executable(executable _executable) {
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < NodeToken >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < varTypeEnum >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:249:16: style: Condition '_pos>-1' is always false [knownConditionTrueFalse]
      if (_pos > -1 && _texts[_pos] != NULL) {
               ^
src/asm_struct_enum.h:248:15: note: Assignment '_pos=-1', assigned value is -1
      _pos = -1;
              ^
src/asm_struct_enum.h:249:16: note: Condition '_pos>-1' is always false
      if (_pos > -1 && _texts[_pos] != NULL) {
               ^
src/NodeToken.h:3034:9: style: Condition 't==NULL' is always false [knownConditionTrueFalse]
  if (t == NULL) {
        ^
src/NodeToken.h:3019:10: note: Assuming that condition 'nd==NULL' is not redundant
  if (nd == NULL) {
         ^
src/NodeToken.h:3033:18: note: Assignment 't=nd', assigned value is 0
  NodeToken *t = nd; // cntx.findFunction(nd->_token);
                 ^
src/NodeToken.h:3034:9: note: Condition 't==NULL' is always false
  if (t == NULL) {
        ^
src/execute.h:348:14: style: Condition '!toResetSync' is always false [knownConditionTrueFalse]
      while (!toResetSync) {
             ^
src/execute.h:347:21: note: Assignment 'toResetSync=true', assigned value is 1
      toResetSync = true;
                    ^
src/execute.h:348:14: note: Condition '!toResetSync' is always false
      while (!toResetSync) {
             ^
src/NodeToken.h:3868:13: warning: %lu in format string (no. 1) requires 'unsigned long *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
            sscanf(ndt->getTokenText(), "%lu", &__num);
            ^
src/execute.h:448:7: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
      ^
src/execute.h:448:7: warning: %ld in format string (no. 2) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
      ^
src/asm_struct_enum.h:502:5: information: --check-library: Function push_back() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return parsed_lines.back();
    ^
src/tokenizer.h:861:51: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
    tokenizer(script, true, increae_line, nbToken);
                                                  ^
src/tokenizer.h:870:53: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
    tokenizer(script, update, increae_line, nbToken);
                                                    ^
src/NodeToken.h:25:51: information: --check-library: Function ESP_LOGD() should have <noreturn> configuration [checkLibraryNoReturn]
  ESP_LOGD("ESPLiveScript", "%s\r\n", str.c_str());
                                                  ^
src/NodeToken.h:33:59: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
void pushToConsole(string str) { pushToConsole(str, false); }
                                                          ^
src/NodeToken.h:124:67: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                              (__endtime - __starttime) / 240000));
                                                                  ^
src/NodeToken.h:126:37: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
void displayStat() { displayStat(""); }
                                    ^
src/NodeToken.h:1741:60: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
    translateType(globalType.get(), r, register_numr.get());
                                                           ^
src/NodeToken.h:2223:74: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
        translateType(globalType.get(), v->_varType, register_numl.get());
                                                                         ^
src/NodeToken.h:2579:41: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                    register_numl.get());
                                        ^
src/NodeToken.h:3459:46: information: --check-library: Function _visitCallFunctionTemplate() should have <noreturn> configuration [checkLibraryNoReturn]
    _visitCallFunctionTemplate(nd, 10, false);
                                             ^
src/NodeToken.h:3626:43: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                      register_numl.get());
                                          ^
src/execute_asm.h:7:37: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(bin->binary_data);
                                    ^
src/execute_asm.h:9:39: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(bin->function_data);
                                      ^
src/execute_asm.h:173:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/execute_asm.h:180:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/execute_asm.h:314:9: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
      :);
        ^
src/execute_asm.h:389:46: information: --check-library: Function heap_caps_aligned_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_aligned_free(ex->start_program);
                                             ^
src/execute_asm.h:396:29: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(ex->data);
                            ^
src/execute_asm.h:419:22: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                true);
                     ^
src/execute_asm.h:664:44: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
                        (void *)&showError);
                                           ^
src/execute.h:64:16: information: --check-library: Function vTaskDelay() should have <noreturn> configuration [checkLibraryNoReturn]
  vTaskDelay(1);
               ^
src/execute.h:128:68: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
    xEventGroupSync(xCreatedEventGroup2, MASK, MASK, portMAX_DELAY);
                                                                   ^
src/execute.h:163:19: information: --check-library: Function _prekill() should have <noreturn> configuration [checkLibraryNoReturn]
        _prekill();
                  ^
src/execute.h:169:20: information: --check-library: Function _postkill() should have <noreturn> configuration [checkLibraryNoReturn]
        _postkill();
                   ^
src/execute.h:213:54: information: --check-library: Function xEventGroupClearBits() should have <noreturn> configuration [checkLibraryNoReturn]
      xEventGroupClearBits(xCreatedEventGroup2, MASK);
                                                     ^
src/execute.h:216:70: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
    xEventGroupSync(xCreatedEventGroup2, 1 << h, MASK, portMAX_DELAY);
                                                                     ^
src/execute.h:293:35: information: --check-library: Function freeExecutable() should have <noreturn> configuration [checkLibraryNoReturn]
      freeExecutable(&_executecmd);
                                  ^
src/execute.h:313:76: information: --check-library: Function vTaskSuspend() should have <noreturn> configuration [checkLibraryNoReturn]
        vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
                                                                           ^
src/execute.h:321:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Program Halted.", true);
                                            ^
src/execute.h:418:57: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole("too many programs at once", true);
                                                        ^
src/execute.h:430:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Execution on going CTRL + k to stop", true);
                                                                ^
src/execute.h:432:49: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Nothing to execute.", true);
                                                ^
src/execute.h:464:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:477:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:556:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:564:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:572:20: information: --check-library: Function vTaskDelete() should have <noreturn> configuration [checkLibraryNoReturn]
  vTaskDelete(NULL);
                   ^
src/execute.h:608:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("please add a name to the executable", true);
                                                                ^
src/ESPLiveScript.h:250:69: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                    ^
src/asm_struct_enum.h:58:18: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
    push(sav + 1);
                 ^
src/asm_struct_enum.h:66:18: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
    push(sav - 1);
                 ^
src/NodeToken.h:1362:10: warning: Either the condition 'p!=NULL' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
  while (p->_nodetype != forNode and p->_nodetype != whileNode) {
         ^
src/NodeToken.h:1367:9: note: Assuming that condition 'p!=NULL' is not redundant
  if (p != NULL) {
        ^
src/NodeToken.h:1362:10: note: Null pointer dereference
  while (p->_nodetype != forNode and p->_nodetype != whileNode) {
         ^
src/NodeToken.h:3015:24: warning: Either the condition 'nd==NULL' is redundant or there is possible null pointer dereference: nd. [nullPointerRedundantCheck]
  int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                       ^
src/NodeToken.h:3019:10: note: Assuming that condition 'nd==NULL' is not redundant
  if (nd == NULL) {
         ^
src/NodeToken.h:3015:24: note: Null pointer dereference
  int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                       ^
src/NodeToken.h:3470:7: warning: Either the condition 'v==NULL' is redundant or there is possible null pointer dereference: v. [nullPointerRedundantCheck]
  if (v->size > 1) {
      ^
src/NodeToken.h:3465:9: note: Assuming that condition 'v==NULL' is not redundant
  if (v == NULL) {
        ^
src/NodeToken.h:3470:7: note: Null pointer dereference
  if (v->size > 1) {
      ^
src/asm_struct_enum.h:499:9: style: C-style pointer casting [cstyleCast]
        (result_parse_line *)malloc(sizeof(result_parse_line));
        ^
src/asm_struct_enum.h:519:9: style: C-style pointer casting [cstyleCast]
        (result_parse_line *)malloc(sizeof(result_parse_line));
        ^
src/execute.h:543:23: style: C-style pointer casting [cstyleCast]
  Executable *exec = ((Executable *)pvParameters);
                      ^
src/NodeToken.h:1486:37: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
      uint32_t __num = (uint32_t)(*((uint32_t *)&__f));
                                    ^
src/NodeToken.h:3865:34: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            __num = (uint32_t)(*((uint32_t *)&__f));
                                 ^
src/asm_struct_enum.h:248:12: style: Redundant initialization for '_pos'. The initialized value is overwritten before it is read. [redundantInitialization]
      _pos = -1;
           ^
src/asm_struct_enum.h:247:16: note: _pos is initialized
      int _pos = findText((char *)str.c_str());
               ^
src/asm_struct_enum.h:248:12: note: _pos is overwritten
      _pos = -1;
           ^
src/execute.h:475:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:472:30: note: res is initialized
    error_message_struct res =
                             ^
src/execute.h:475:9: note: res is overwritten
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:553:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary(exec->df.args[0], exec->df.exe,
        ^
src/execute.h:550:30: note: res is initialized
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                             ^
src/execute.h:553:9: note: res is overwritten
    res = executeBinary(exec->df.args[0], exec->df.exe,
        ^
src/execute.h:561:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,
        ^
src/execute.h:559:30: note: res is initialized
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                             ^
src/execute.h:561:9: note: res is overwritten
    res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,
        ^
src/ESPLiveScript.h:107:18: style: Variable 'point_regnum' is reassigned a value before the old one has been used. [redundantAssignment]
    point_regnum = 4;
                 ^
src/ESPLiveScript.h:106:18: note: point_regnum is assigned
    point_regnum = 4;
                 ^
src/ESPLiveScript.h:107:18: note: point_regnum is overwritten
    point_regnum = 4;
                 ^
src/NodeToken.h:3024:5: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
    if (isExtCall)
    ^
src/NodeToken.h:3026:5: note: Found duplicate branches for 'if' and 'else'.
    else
    ^
src/NodeToken.h:3024:5: note: Found duplicate branches for 'if' and 'else'.
    if (isExtCall)
    ^
src/NodeToken.h:4482:7: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
      if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
      ^
src/NodeToken.h:4486:7: note: Found duplicate branches for 'if' and 'else'.
      else
      ^
src/NodeToken.h:4482:7: note: Found duplicate branches for 'if' and 'else'.
      if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
      ^
src/NodeToken.h:1342:5: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
    break;
    ^
src/NodeToken.h:1448:5: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
    break;
    ^
src/NodeToken.h:3404:15: style: The scope of the variable 'sav' can be reduced. [variableScope]
          int sav;
              ^
src/NodeToken.h:3712:7: style: The scope of the variable 'sav' can be reduced. [variableScope]
  int sav = 9;
      ^
src/NodeToken.h:3859:15: style: The scope of the variable 'c' can be reduced. [variableScope]
      uint8_t c;
              ^
src/NodeToken.h:4733:17: style: The scope of the variable 'ind' can be reduced. [variableScope]
            int ind = -1;
                ^
src/asm_parser.h:77:9: style: The scope of the variable 'add_size' can be reduced. [variableScope]
    int add_size = 0;
        ^
src/asm_parser.h:392:12: style: The scope of the variable 'values' can be reduced. [variableScope]
  uint32_t values[4];
           ^
src/execute_asm.h:230:8: style: The scope of the variable 'ver' can be reduced. [variableScope]
  char ver[19];
       ^
src/ESPLiveScript.h:2715:11: style: The scope of the variable 'j' can be reduced. [variableScope]
      int j = 0;
          ^
src/execute.h:578:34: style:inconclusive: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'. [funcArgNamesDifferent]
void _executablesClass::kill(int handle_number) {
                                 ^
src/execute.h:101:17: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
  void kill(int handle);
                ^
src/execute.h:578:34: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
void _executablesClass::kill(int handle_number) {
                                 ^
src/tokenizer.h:1689:12: style: Local variable 'c2' shadows outer variable [shadowVariable]
      char c2 = script->nextChar();
           ^
src/tokenizer.h:1117:8: note: Shadowed declaration
  char c2;
       ^
src/tokenizer.h:1689:12: note: Shadow variable
      char c2 = script->nextChar();
           ^
src/tokenizer.h:1847:16: style: Local variable 'c2' shadows outer variable [shadowVariable]
          char c2 = script->nextChar();
               ^
src/tokenizer.h:1117:8: note: Shadowed declaration
  char c2;
       ^
src/tokenizer.h:1847:16: note: Shadow variable
          char c2 = script->nextChar();
               ^
src/NodeToken.h:966:16: style: Local variable '__tmpToken' shadows outer variable [shadowVariable]
    NodeToken *__tmpToken = new NodeToken();
               ^
src/NodeToken.h:395:12: note: Shadowed declaration
NodeToken *__tmpToken;
           ^
src/NodeToken.h:966:16: note: Shadow variable
    NodeToken *__tmpToken = new NodeToken();
               ^
src/NodeToken.h:2275:9: style: Local variable 'start' shadows outer variable [shadowVariable]
    int start = nd->stack_pos;
        ^
src/NodeToken.h:2264:7: note: Shadowed declaration
  int start = nd->stack_pos;
      ^
src/NodeToken.h:2275:9: note: Shadow variable
    int start = nd->stack_pos;
        ^
src/NodeToken.h:3725:13: style: Local variable 'start' shadows outer variable [shadowVariable]
        int start = nd->getChildAtPos(i)->stack_pos;
            ^
src/NodeToken.h:3722:11: note: Shadowed declaration
      int start = nd->getChildAtPos(i)->stack_pos;
          ^
src/NodeToken.h:3725:13: note: Shadow variable
        int start = nd->getChildAtPos(i)->stack_pos;
            ^
src/NodeToken.h:4621:24: style: Local variable 'd2' shadows outer variable [shadowVariable]
        vector<string> d2 = split(tmp, " ");
                       ^
src/NodeToken.h:4567:18: note: Shadowed declaration
  vector<string> d2;
                 ^
src/NodeToken.h:4621:24: note: Shadow variable
        vector<string> d2 = split(tmp, " ");
                       ^
src/NodeToken.h:4625:26: style: Local variable 'd' shadows outer variable [shadowVariable]
          vector<string> d = split(before, " ");
                         ^
src/NodeToken.h:4566:18: note: Shadowed declaration
  vector<string> d;
                 ^
src/NodeToken.h:4625:26: note: Shadow variable
          vector<string> d = split(before, " ");
                         ^
src/NodeToken.h:4734:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4734:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:4774:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4774:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:4860:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4860:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:4915:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4915:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:4965:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4965:18: note: Shadow variable
            bool found = false;
                 ^
src/asm_parser.h:1119:22: style: Local variable '__v' shadows outer variable [shadowVariable]
      vector<string> __v = split(trim(str), " ");
                     ^
src/tokenizer.h:62:9: note: Shadowed declaration
varType __v;
        ^
src/asm_parser.h:1119:22: note: Shadow variable
      vector<string> __v = split(trim(str), " ");
                     ^
src/execute_asm.h:48:16: style: Local variable 'content' shadows outer variable [shadowVariable]
      uint32_t content = bincode + address;
               ^
src/NodeToken.h:341:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:48:16: note: Shadow variable
      uint32_t content = bincode + address;
               ^
src/execute_asm.h:63:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:341:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:63:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/execute_asm.h:98:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:341:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:98:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/execute_asm.h:349:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = 1; i < args.size(); i++) {
                 ^
src/execute_asm.h:324:12: note: Shadowed declaration
  for (int i = 0; i < ex.functions.size(); i++) {
           ^
src/execute_asm.h:349:18: note: Shadow variable
        for (int i = 1; i < args.size(); i++) {
                 ^
src/ESPLiveScript.h:331:20: style: Local variable 'i' shadows outer variable [shadowVariable]
          for (int i = 0; i < __DEPTH; i++) {
                   ^
src/ESPLiveScript.h:316:16: note: Shadowed declaration
      for (int i = 0; i < external_links.size(); i++) {
               ^
src/ESPLiveScript.h:331:20: note: Shadow variable
          for (int i = 0; i < __DEPTH; i++) {
                   ^
src/ESPLiveScript.h:422:21: style: Local variable 'nd' shadows outer variable [shadowVariable]
          NodeToken nd = NodeToken(changeTypeNode);
                    ^
src/ESPLiveScript.h:396:17: note: Shadowed declaration
      NodeToken nd = NodeToken(changeTypeNode);
                ^
src/ESPLiveScript.h:422:21: note: Shadow variable
          NodeToken nd = NodeToken(changeTypeNode);
                    ^
src/ESPLiveScript.h:667:14: style: Local variable '_signature' shadows outer variable [shadowVariable]
      string _signature = sigs.back() + "*";
             ^
src/ESPLiveScript.h:662:12: note: Shadowed declaration
    string _signature = sigs.back() + current_node->getVarType()->varName;
           ^
src/ESPLiveScript.h:667:14: note: Shadow variable
      string _signature = sigs.back() + "*";
             ^
src/ESPLiveScript.h:681:17: style: Local variable 'nd' shadows outer variable [shadowVariable]
      NodeToken nd = NodeToken(changeTypeNode);
                ^
src/ESPLiveScript.h:650:15: note: Shadowed declaration
    NodeToken nd = NodeToken(changeTypeNode);
              ^
src/ESPLiveScript.h:681:17: note: Shadow variable
      NodeToken nd = NodeToken(changeTypeNode);
                ^
src/ESPLiveScript.h:692:14: style: Local variable '_signature' shadows outer variable [shadowVariable]
      string _signature =
             ^
src/ESPLiveScript.h:662:12: note: Shadowed declaration
    string _signature = sigs.back() + current_node->getVarType()->varName;
           ^
src/ESPLiveScript.h:692:14: note: Shadow variable
      string _signature =
             ^
src/ESPLiveScript.h:698:16: style: Local variable '_signature' shadows outer variable [shadowVariable]
        string _signature = sigs.back() + "*";
               ^
src/ESPLiveScript.h:692:14: note: Shadowed declaration
      string _signature =
             ^
src/ESPLiveScript.h:698:16: note: Shadow variable
        string _signature = sigs.back() + "*";
               ^
src/ESPLiveScript.h:1898:17: style: Local variable '_nd' shadows outer variable [shadowVariable]
      NodeToken _nd = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:1861:15: note: Shadowed declaration
    NodeToken _nd = nodeTokenList.pop();
              ^
src/ESPLiveScript.h:1898:17: note: Shadow variable
      NodeToken _nd = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:1900:17: style: Local variable '_t' shadows outer variable [shadowVariable]
      NodeToken _t = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:1863:15: note: Shadowed declaration
    NodeToken _t = nodeTokenList.pop();
              ^
src/ESPLiveScript.h:1900:17: note: Shadow variable
      NodeToken _t = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:2914:27: style: Local variable 'nd' shadows outer variable [shadowVariable]
                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                          ^
src/ESPLiveScript.h:2886:25: note: Shadowed declaration
              NodeToken nd = NodeToken(current(), defLocalVariableNode);
                        ^
src/ESPLiveScript.h:2914:27: note: Shadow variable
                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                          ^
src/ESPLiveScript.h:3008:27: style: Local variable 'nd' shadows outer variable [shadowVariable]
                NodeToken nd = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:2985:23: note: Shadowed declaration
            NodeToken nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3008:27: note: Shadow variable
                NodeToken nd = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:3009:27: style: Local variable '_t' shadows outer variable [shadowVariable]
                NodeToken _t = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:2986:23: note: Shadowed declaration
            NodeToken _t = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3009:27: note: Shadow variable
                NodeToken _t = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:3120:25: style: Local variable 'nd' shadows outer variable [shadowVariable]
              NodeToken nd = NodeToken(*current_node);
                        ^
src/ESPLiveScript.h:2985:23: note: Shadowed declaration
            NodeToken nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3120:25: note: Shadow variable
              NodeToken nd = NodeToken(*current_node);
                        ^
src/ESPLiveScript.h:3154:25: style: Local variable 'nd' shadows outer variable [shadowVariable]
              NodeToken nd = NodeToken(*current_node);
                        ^
src/ESPLiveScript.h:2985:23: note: Shadowed declaration
            NodeToken nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3154:25: note: Shadow variable
              NodeToken nd = NodeToken(*current_node);
                        ^
src/asm_external.h:22:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalFunction(string name, string out, string in, void *ptr) {
                                ^
src/asm_external.h:22:58: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalFunction(string name, string out, string in, void *ptr) {
                                                         ^
src/asm_external.h:59:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out, string in, void *ptr) {
                                ^
src/asm_external.h:59:46: performance: Function parameter 'out' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out, string in, void *ptr) {
                                             ^
src/asm_external.h:59:58: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out, string in, void *ptr) {
                                                         ^
src/asm_external.h:69:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternal(string name, externalType type, void *ptr) {
                        ^
src/asm_struct_enum.h:127:33: performance: Function parameter 's' should be passed by const reference. [passedByValue]
  void addAfter(int pos, string s) {
                                ^
src/asm_struct_enum.h:138:34: performance: Function parameter 's' should be passed by const reference. [passedByValue]
  void addBefore(int pos, string s) {
                                 ^
src/tokenizer.h:488:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalDefine(string name, string content) {
                              ^
src/tokenizer.h:488:44: performance: Function parameter 'content' should be passed by const reference. [passedByValue]
void addExternalDefine(string name, string content) {
                                           ^
src/tokenizer.h:985:25: performance: Function parameter 't' should be passed by const reference. [passedByValue]
void displaytoken(token t) {
                        ^
src/NodeToken.h:33:27: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
void pushToConsole(string str) { pushToConsole(str, false); }
                          ^
src/NodeToken.h:518:20: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
  NodeToken(string _target, nodeType tt) {
                   ^
src/NodeToken.h:523:47: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
  NodeToken(NodeToken nd, nodeType tt, string _target) {
                                              ^
src/asm_parser.h:387:41: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
result_parse_line parseOperandes(string str, int nboperande,
                                        ^
src/asm_parser.h:427:22: performance: Function parameter 's' should be passed by const reference. [passedByValue]
int findLabel(string s, parsedLines *asm_parsed) {
                     ^
src/execute.h:383:27: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
  int _run(vector<string> args, bool second_core, int core,
                          ^
src/execute.h:384:22: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
           Arguments arguments) {
                     ^
src/execute.h:457:27: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeOnly(string prog) {
                          ^
src/execute.h:468:23: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void execute(string prog) {
                      ^
src/execute.h:482:23: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void execute(string prog, Arguments arguments) {
                      ^
src/execute.h:501:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core, Arguments arguments) {
                            ^
src/execute.h:518:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, Arguments arguments) {
                            ^
src/execute.h:518:45: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, Arguments arguments) {
                                            ^
src/execute.h:521:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog) {
                            ^
src/execute.h:526:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core) {
                            ^
src/execute.h:611:37: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void addExe(Executable df, string name) {
                                    ^
src/execute.h:624:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name) {
                      ^
src/execute.h:633:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, string function) {
                      ^
src/execute.h:642:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, Arguments arguments) {
                      ^
src/execute.h:652:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, string function, Arguments arguments) {
                      ^
src/execute.h:661:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, Arguments arguments) {
                            ^
src/execute.h:670:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name) {
                            ^
src/execute.h:680:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, string function, Arguments arguments) {
                            ^
src/execute.h:689:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, string function) {
                            ^
src/execute.h:698:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, int core, Arguments args) {
                            ^
src/execute.h:707:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, int core) {
                            ^
src/execute.h:716:20: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void kill(string name) {
                   ^
src/execute.h:742:20: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void free(string name) {
                   ^
src/execute.h:781:37: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  exe_info getExecutableInfo(string name) {
                                    ^
src/asm_struct_enum.h:18:11: performance: Function parameter 'def' should be passed by const reference. [passedByValue]
  Stack(T def) { _default = def; }
          ^
src/ESPLiveScript.h:158:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(Error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:224:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(bin.error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:250:9: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
        pushToConsole(_executecmd.error.error_message.c_str(), true);
        ^
src/NodeToken.h:1147:44: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        if (findfloat(child) == __float__) {
                                           ^
src/NodeToken.h:1163:47: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        if (findfloat(child) == __uint32_t__) {
                                              ^
src/asm_external.h:57:28: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:57:28: error: Uninitialized struct member: asmex.offset [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:67:28: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:67:28: error: Uninitialized struct member: asmex.offset [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:76:28: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:76:28: error: Uninitialized struct member: asmex.offset [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_parser.h:145:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:153:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:145:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:153:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:173:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:181:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:173:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:181:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:201:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:209:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:201:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:209:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:229:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:239:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:229:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:239:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:258:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:268:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:258:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:268:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:284:19: error: Uninitialized struct member: error.line [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:290:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:284:19: error: Uninitialized struct member: error.pos [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:290:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:1061:15: error: Uninitialized struct member: err.line [uninitStructMember]
  asm_Error = err;
              ^
src/asm_parser.h:1061:15: error: Uninitialized struct member: err.pos [uninitStructMember]
  asm_Error = err;
              ^
src/execute.h:792:12: error: Uninitialized variable: inf [uninitvar]
    return inf;
           ^
src/execute.h:785:11: note: Assuming condition is false
    if (f != NULL) {
          ^
src/execute.h:792:12: note: Uninitialized variable: inf
    return inf;
           ^
src/execute.h:797:14: error: Uninitialized variable: inf [uninitvar]
      return inf;
             ^
src/NodeToken.h:588:15: style: Variable 'nd.parent' is assigned a value that is never used. [unreadVariable]
    nd.parent = this;
              ^
src/NodeToken.h:1007:11: style: Unused variable: tocmp [unusedVariable]
    char *tocmp;
          ^
src/NodeToken.h:1032:11: style: Unused variable: tocmp [unusedVariable]
    char *tocmp;
          ^
src/NodeToken.h:2436:11: style: Variable 'sav' is assigned a value that is never used. [unreadVariable]
  int sav = 9;
          ^
src/NodeToken.h:3018:15: style: Variable 'nbfloat' is assigned a value that is never used. [unreadVariable]
  int nbfloat = 0;
              ^
src/NodeToken.h:3672:16: style: Variable 't' is assigned a value that is never used. [unreadVariable]
  NodeToken *t = nd;
               ^
src/NodeToken.h:3858:13: style: Variable '__num' is assigned a value that is never used. [unreadVariable]
      __num = 0;
            ^
src/asm_parser.h:77:18: style: Variable 'add_size' is assigned a value that is never used. [unreadVariable]
    int add_size = 0;
                 ^
src/execute_asm.h:31:9: style: Unused variable: textptr2 [unusedVariable]
  char *textptr2;
        ^
src/ESPLiveScript.h:2795:19: style: Variable 'memberpos' is assigned a value that is never used. [unreadVariable]
    int memberpos = 0;
                  ^
src/ESPLiveScript.h:2796:16: style: Variable '_start' is assigned a value that is never used. [unreadVariable]
    int _start = 0;
               ^
src/ESPLiveScript.h:2797:14: style: Variable '_pos' is assigned a value that is never used. [unreadVariable]
    int _pos = 0;
             ^
main.cpp:15:19: style: Variable 'exec' is assigned a value that is never used. [unreadVariable]
  Executable exec = _parser.parseScript(&script);
                  ^
src/asm_external.h:81:35: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it < external_links.end(); it++) {
                                  ^
src/asm_struct_enum.h:163:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      _it--;
      ^
src/asm_struct_enum.h:238:5: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    _it++;
    ^
src/asm_struct_enum.h:269:10: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
         it++) {
         ^
src/asm_struct_enum.h:341:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      _it--;
      ^
src/tokenizer.h:714:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        it--;
        ^
src/tokenizer.h:734:5: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    it++;
    ^
src/tokenizer.h:744:10: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
         _it++) {
         ^
src/tokenizer.h:754:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it++;
      ^
src/NodeToken.h:1382:39: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
         it != __nd->children->end(); it++) {
                                      ^
src/asm_parser.h:105:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != _asm_parsed.end(); it++) {
                                ^
src/asm_parser.h:120:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != _asm_parsed.end(); it++) {
                                ^
src/asm_parser.h:431:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:449:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1302:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1368:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1408:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1441:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/asm_parser.h:1454:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1517:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/execute.h:732:40: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
           it != _scExecutables.end(); it++) {
                                       ^
src/NodeToken.h:150:16: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
  displayStat();
               ^
src/execute_asm.h:473:19: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
  uint8_t third = scale8(offset8, (256 / 3)); // max = 85
                  ^
src/execute_asm.h:501:31: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
          uint8_t twothirds = scale8(offset8, ((256 * 2) / 3)); // max=170
                              ^
src/execute_asm.h:515:31: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
          uint8_t twothirds = scale8(offset8, ((256 * 2) / 3)); // max=170
                              ^
src/execute_asm.h:547:29: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        uint8_t twothirds = scale8(offset8, ((256 * 2) / 3)); // max=170
                            ^
src/execute_asm.h:584:9: information: --check-library: There is no matching configuration for function scale8_video_LEAVING_R1_DIRTY() [checkLibraryFunction]
    g = scale8_video_LEAVING_R1_DIRTY(g, Gscale);
        ^
src/execute_asm.h:595:15: information: --check-library: There is no matching configuration for function scale8_video() [checkLibraryFunction]
      desat = scale8_video(desat, desat);
              ^
src/execute_asm.h:608:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        r = scale8(r, satscale) + 1;
            ^
src/execute_asm.h:610:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        g = scale8(g, satscale) + 1;
            ^
src/execute_asm.h:612:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        b = scale8(b, satscale) + 1;
            ^
src/execute_asm.h:624:11: information: --check-library: There is no matching configuration for function scale8_video_LEAVING_R1_DIRTY() [checkLibraryFunction]
    val = scale8_video_LEAVING_R1_DIRTY(val, val);
          ^
src/execute_asm.h:638:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        r = scale8(r, val) + 1;
            ^
src/execute_asm.h:640:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        g = scale8(g, val) + 1;
            ^
src/execute_asm.h:642:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        b = scale8(b, val) + 1;
            ^
src/execute_asm.h:653:10: information: --check-library: There is no matching configuration for function CRGB() [checkLibraryFunction]
  return CRGB(r, g, b);
         ^
src/execute_asm.h:488:27: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
        FORCE_REFERENCE(b);
                          ^
src/execute_asm.h:496:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:504:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:519:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:525:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:666:67: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
    addExternalFunction("hsv", "CRGB", "int,int,int", (void *)hsv);
                                                                  ^
src/execute.h:254:19: information: --check-library: There is no matching configuration for function createExectutable() [checkLibraryFunction]
    _executecmd = createExectutable(bin);
                  ^
src/execute.h:293:7: information: --check-library: There is no matching configuration for function freeExecutable() [checkLibraryFunction]
      freeExecutable(&_executecmd);
      ^
src/execute.h:445:7: information: --check-library: There is no matching configuration for function freeExecutable() [checkLibraryFunction]
      freeExecutable(&_executecmd);
      ^
src/execute.h:462:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@_" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:473:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@__footer", _executecmd, 9999, this, d);
        ^
src/execute.h:475:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
          ^
src/execute.h:490:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@__footer", _executecmd, 9999, this, d);
        ^
src/execute.h:494:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
          ^
src/execute.h:550:32: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                               ^
src/execute.h:553:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary(exec->df.args[0], exec->df.exe,
          ^
src/execute.h:559:32: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                               ^
src/execute.h:561:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,
          ^
src/ESPLiveScript.h:205:11: information: --check-library: There is no matching configuration for function createBinary() [checkLibraryFunction]
    bin = createBinary(&footer, &header, &content, __parser_debug);
          ^
src/ESPLiveScript.h:225:7: information: --check-library: There is no matching configuration for function freeBinary() [checkLibraryFunction]
      freeBinary(&bin);
      ^
src/ESPLiveScript.h:240:32: information: --check-library: There is no matching configuration for function createExectutable() [checkLibraryFunction]
      executable _executecmd = createExectutable(&bin);
                               ^
src/NodeToken.h:22:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole(str, force);
        ^
src/ESPLiveScript.h:3243:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Something Already running kill it first ...");
            ^
src/ESPLiveScript.h:3259:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(config.ENDLINE);
    ^
src/ESPLiveScript.h:3260:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
    ^
src/ESPLiveScript.h:3260:17: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
                ^
src/ESPLiveScript.h:3291:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("Compiling ...", true);
          ^
src/ESPLiveScript.h:3298:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("filename missing ...", true);
          ^
src/ESPLiveScript.h:3315:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Something Already running kill it first ...");
            ^
src/ESPLiveScript.h:3339:14: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
      Serial.printf("oioioioe");
             ^
src/ESPLiveScript.h:3350:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("***********START RUN *********");
              ^
src/ESPLiveScript.h:3355:11: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
          _push(config.ENDLINE);
          ^
src/ESPLiveScript.h:3356:11: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
          _push(cons->prompt(cons).c_str());
          ^
src/ESPLiveScript.h:3356:23: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
          _push(cons->prompt(cons).c_str());
                      ^
src/ESPLiveScript.h:3359:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Start program", true);
              ^
src/ESPLiveScript.h:3362:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Execution done.", true);
              ^
src/ESPLiveScript.h:3368:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("filename missing ...", true);
          ^
src/ESPLiveScript.h:3373:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("Something Already running kill it first ...");
          ^
src/ESPLiveScript.h:3380:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole("Compiling ...", true);
        ^
src/ESPLiveScript.h:3396:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("***********START RUN *********");
            ^
src/ESPLiveScript.h:3400:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(config.ENDLINE);
        ^
src/ESPLiveScript.h:3401:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
        ^
src/ESPLiveScript.h:3401:21: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
                    ^
src/ESPLiveScript.h:3404:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Start program", true);
            ^
src/ESPLiveScript.h:3407:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Execution done.", true);
            ^
src/ESPLiveScript.h:3410:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole(SCExecutable.error.error_message, true);
          ^
src/ESPLiveScript.h:3424:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(config.ENDLINE);
    ^
src/ESPLiveScript.h:3425:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
    ^
src/ESPLiveScript.h:3425:17: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
                ^
src/ESPLiveScript.h:3435:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand(
          ^
src/ESPLiveScript.h:3438:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("comp", compile_c, "Compile  a program");
          ^
src/ESPLiveScript.h:3439:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("createbin", saveBin,
          ^
src/ESPLiveScript.h:3441:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("executebin", binload, "executebin");
          ^
src/ESPLiveScript.h:3442:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("displaybin", displaybin, "displaybin");
          ^
src/ESPLiveScript.h:3443:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("./", binload, "executebin");
          ^
src/ESPLiveScript.h:3444:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("list", listExec, "list the compiled programs");
          ^
src/ESPLiveScript.h:3445:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand(
          ^
src/ESPLiveScript.h:3448:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("run", run,
          ^
src/ESPLiveScript.h:3451:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand(
          ^
src/ESPLiveScript.h:3454:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("parseasm", parseasm, "Parse assembly program");
          ^
src/ESPLiveScript.h:3455:11: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
    LedOS.addEscCommand(18, parsec_cEsc,
          ^
src/ESPLiveScript.h:3457:11: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
    LedOS.addEscCommand(11, kill_cEsc, "Stop a running program");
          ^
src/ESPLiveScript.h:3611:11: information: --check-library: There is no matching configuration for function LedOS::addHightLightinf() [checkLibraryFunction]
    LedOS.addHightLightinf("sc", formatLine, formatInit, formatLine);
          ^
src/ESPLiveScript.h:3201:59: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Nothing is currently running.", true);
                                                          ^
src/ESPLiveScript.h:3244:23: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
      kill(cons, args);
                      ^
src/ESPLiveScript.h:3260:38: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
    _push(cons->prompt(cons).c_str());
                                     ^
src/ESPLiveScript.h:3273:24: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                  true);
                       ^
src/ESPLiveScript.h:3275:47: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(_scExec.error.error_message);
                                              ^
src/ESPLiveScript.h:3296:21: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
    freeBinary(&bin);
                    ^
src/ESPLiveScript.h:3306:21: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
    freeBinary(&bin);
                    ^
src/ESPLiveScript.h:3317:20: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
      kill(cons, k);
                   ^
src/ESPLiveScript.h:3341:67: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                  ^
src/ESPLiveScript.h:3356:44: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
          _push(cons->prompt(cons).c_str());
                                           ^
src/ESPLiveScript.h:3375:18: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
    kill(cons, k);
                 ^
src/ESPLiveScript.h:3401:42: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
        _push(cons->prompt(cons).c_str());
                                         ^
src/ESPLiveScript.h:3425:38: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
    _push(cons->prompt(cons).c_str());
                                     ^
src/NodeToken.h:1361:14: style: Local variable 'p' shadows outer variable [shadowVariable]
  NodeToken *p = current_node;
             ^
src/ESPLiveScript.h:3193:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:1361:14: note: Shadow variable
  NodeToken *p = current_node;
             ^
src/NodeToken.h:4634:28: style: Local variable 'p' shadows outer variable [shadowVariable]
            vector<string> p = split(d[1], ",");
                           ^
src/ESPLiveScript.h:3193:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:4634:28: note: Shadow variable
            vector<string> p = split(d[1], ",");
                           ^
src/ESPLiveScript.h:3208:33: performance: Function parameter 'variables' should be passed by const reference. [passedByValue]
Arguments parseInputArgs(string variables) {
                                ^
src/ESPLiveScript.h:3263:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void parseasm(Console *cons, vector<string> args) {}
                                            ^
src/ESPLiveScript.h:3264:46: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void compile_c(Console *cons, vector<string> args) {
                                             ^
src/ESPLiveScript.h:3429:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void listExec(Console *cons, vector<string> args) { scriptRuntime.listExec(); }
                                            ^
src/ESPLiveScript.h:3327:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(bin.error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:3341:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(_executecmd.error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:291:10: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
      sc = sc + "\n" + s;
         ^
src/ESPLiveScript.h:303:10: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
      sc = sc + "\n" + s;
         ^
src/ESPLiveScript.h:3298:54: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    LedOS.pushToConsole("filename missing ...", true);
                                                     ^
src/ESPLiveScript.h:3368:54: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    LedOS.pushToConsole("filename missing ...", true);
                                                     ^
src/ESPLiveScript.h:3319:20: style: Variable 'othercore' is assigned a value that is never used. [unreadVariable]
    bool othercore = false;
                   ^
src/asm_struct_enum.h:204:13: style: Condition '!isReused(0)' is always true [knownConditionTrueFalse]
        if (!isReused(0)) {
            ^
src/asm_struct_enum.h:93:5: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    for (int i = _texts.size() - 1; i >= 0; i--) {
    ^
src/asm_struct_enum.h:321:5: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    if (pos < 0 or pos >= _texts.size()) {
    ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

